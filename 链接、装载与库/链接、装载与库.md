# 编译和链接

## 被隐藏了的过程

在Linux下，使用GCC来编译Hello World程序时，只使用最简单的命令

```bash
$gcc hello.c
$./a.out
Hello World
```

上面的过程可以分解为4个步骤

-   预处理(Prepressing)
-   编译(Compilation)
-   汇编(Assembly)
-   链接(Linking)

![[链接、装载与库1.png]]

### 预编译

源代码文件hello.c和相关的头文件，被编译器预编译为.i文件，第一步预编译的过程相当于

$gcc -E hello.c -o hello.i

或者

$cpp hello.c > hello.i

预编译过程主要处理那些源代码文件中以’#’开始的预编译指令。比如“#include”、“#define”

主要处理规则如下：、

-   将所有的“#define”删除，并且展开所有的宏定义
-   处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”
-   处理“#include”预编译·指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的文件还可能包含其他文件
-   删除所有的注释“//”和“/**/”
-   添加行号和文件名标识，比如#2 “hello.c”“2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号
-   保留所有的#pragma编译器指令，因为编译器必须要使用它们

经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中

### 编译

编译的过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也就是最复杂的部分之一

### 汇编

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，只是根据汇编指令和机器指令的对照一一翻译就可以

### 链接

？？？

## 编译器做了什么

### 词法分析

首先源代码被输入到扫描器，扫描器进行简单的词法分析，运用一种类似于有限状态机的算法可以很简单的将源代码的字符序列分割成一系列的记号

词法分析产生的记号一般可以分为如下几类：

-   关键字
-   标识符
-   字面量（包含数字、字符串等）
-   特殊符号（如加号、等号）

在识别符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用

### 语法分析

语法分析器对有扫描器产生的记号进行语法分析，从而产生语法树。整个过程采用了上下文无关语法的分析手段

简单的讲，由语法分析器生成的语法树就是以表达式为节点的树

### 语义分析

语法分析仅仅完成了对表达式的语法层面的分析，语义分析则是由语义分析器来完成，编译器所能分析的语义是静态语义，所谓静态语义是指在编译器可以确定的语义，与之对应的动态语义就是只有在运行期间才能确定的语义

静态语义通常包括声明和类型的匹配，类型的转换

在经过语义分析后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序就会在语法树中插入相应的转换节点

### 中间语言生成

源代码优化器往往将整个语法树转换为中间代码，它是语法树的顺序表示，已经很接近目标代码了 但是他一般和运行时的目标环境是无关的

比较常见的有： 三地址码 、P-代码

### 目标代码的生成和优化

编译器后端主要包括代码生成器和目标代码优化器

## 模块拼装——静态链接

链接的过程主要包括********************************************************************************************************************地址和空间分配********************************************************************************************************************、********************************************************************************************************************符号决议********************************************************************************************************************和********************************************************************************************************************重定位********************************************************************************************************************

每个模块的源代码文件经过编译器编译为目标文件，目标文件和库一起链接形成最终的可执行文件。而最常用的文件就是运行时库，它是支持程序运行的基本函数的集合

现代的编译和链接过程并没有想象中那么复杂，比如说在程序模块main.c中使用另外一个模块fun.c中的函数foo()。那么在main.c模块每一处调用foo()的地方都需要确切的知道foo()的地址，但是由于每个模块都是单独编译的。编译器在编译main.c时，并不知道foo函数的地址，所以将这些调用foo指令的目标地址搁置，等待最后链接的时候由链接器去将这些指令的地址修正

地址修正的过程也被叫做**重定位**，每个要被修正的地方叫做一个**重定位入口。**重定位所作的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址

# 目标文件

## 目标文件的格式

现在PC平台流行的可执行文件格式主要是Windows下的PE和Linux的ELF，它们都是COFF格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（Windows下的.obj和Linux下的.o），它跟着可执行文件的内容和结构很相似，所以一般跟可执行文件格式一起采用一种格式存储。从广义上看，目标文件与可执行文件的格式其实几乎是一样的，所以我们可以广义地将目标文件与可执行文件看作是一种类型的文件，在windows下可以统称为PE-COFF文件格式。在Linux下，我们可以将他们统称为ELF文件。其他不太常见的可执行文件格式还有Intel/Microsoft的OMF、Unix a.out格式和MS-DOS .COM 格式等

不光是可执行文件（.exe ELF）按照可执行文件格式存储。

动态链接库(DLL .so)以及静态链接库（.ib和.a）文件都按照可执行文件格式存储。它们在Windows下都按照PE-COFF格式存储，Linux下按照ELF格式存储

静态链接库稍有不同，它是把很多目标文件捆绑在一起形成一个文件，在加上一些索引，可以简单的将其理解为一个包含了很多目标文件的文件包

ELF文件格式

说明

实例

可重定位文件

这类文件包含了代码和数据，可以用来链接成可执行文件或共享文件目标，静态链接库可以归为这一类

linux的.o

Windows的.exe

可执行文件

这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，它们一般都 没有拓展名

/bin/sh文件

Windows的.exe

共享目标文件

这种文件包含了代码和数据，可以在以下两种情况下使用。一种是链接器可以使用这种文件跟其他的可重定位 文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行

[Linux的.so](http://xn--Linux-m81m.so)，如/lib/glibc-2.5.so

Windows的DLL

核心转储文件

当进程意外终止时，系统可以通过将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件

Linux下的core dump

### 目标文件是什么样的

目标文件中的内容除去机器指令代码、数据还包括了链接时需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以“节”的形式存储，有时候也叫做“段”，一般情况下，它们都表示一个一定长度的区域，基本上不加以区别，唯一的区别是在ELF的链接视图和装载视图的时候

程序源代码编译后的机器指令经常被放在代码段里，代码段常见的名字有“.code”或“.text”；全局变量和局部变量数据经常放在数据段，数据段的一般名字叫做“.data”

![[链接、装载与库2.png]]

-   文件头：藐视整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息。文件头还包含一个段表，段表其实是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表里面可以得到每个段的所有信息
-   .text段：一般c语言的编译后执行语句都编译为机器代码
-   .data段：初始化的全局变量和局部静态变量
-   未初始化的全局变量和局部静态变量

> 未初始化的全局变量和局部静态变量默认值都为0，，本来可以放在data段的，但是由于都是0，所以为它们在.data段分配空间并且存放数据0是没有必要的。 程序运行时它们确实是要占内存空间，并且可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和，记为.bss段

<aside> 💡 所有.bss段只是为未初始化的全局变量和局部静态变量预留位置，它没有内容，所以在文件中也不占据空间

</aside>

**总体来说，程序源代码被编译后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据**

程序分段的好处：

-   程序被装载后，数据和指令分别被映射到两个虚存区域。由于数据区域对程序来说是可读写的，而指令区域对进程来说是只读的，所以这两个虚存区域的权限可以被分别设置为可读写和只读。这样可以防止程序的指令被有意或无意的改写
-   对于现代的CPU来说，它们有着极为强大的缓存体系。由于缓存在现代的计算机中地位十分的重要，所以程序必须尽量提高缓存的命中率。指令区和数据区的分离有利于提高程序的局部性
-   当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份该程序的指令部分。对于其他只读数据也是一样的程序中的图标，图片、文本等资源都可以共享，在有动态链接的系统中，可以节省大量的内存

## 挖掘SimpleSection.o

### 代码段

### 数据段和只读数据段

### BSS段

### 其他段

## ELF结构描述

### 文件头

文件头中**ELF魔数、文件机器字节长度、数据储存方式 、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度**及**段的数量**等

### 段表

描述ELF各个段的信息，比如每个段的的段名、段的长度、在文件的偏移、读写权限及段的其他属性

### 重定位表

### 字符串表

## 链接的接口——符号

在链接中，我们将函数和变量统称为符号，函数名或变量名就是符号名

可以将符号看作是链接中的粘合剂，整个链接过程正是基于符号才能完成

-   定义在本目标文件的全局符号，可以被其他文件引用
-   在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号，也就是上面的符号引用
-   段名，这种符号往往由编译器产生，它的值就是这段的起始地址。
-   局部符号，这类符号只在编译单元内部可见
-   行号信息，即目标指令与源码中代码行的对应关系

### ELF符号表结构

************************************符号类型和绑定信息************************************

该成员低四位表示符号的类型，高28位表示符号绑定信息

**************************符号所在段**************************

如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标；但是如果符号不是定义在本目标文件中，或者对于有些特殊符号sh_shndx的值有些特殊

**符号值**

-   在目标文件中，如果是符号的定义并且该符号不是“COMMON”段类型的，则st_value表示该符号在段中的偏移
-   在目标文件中，如果符号是“COMMON”类型的则st_value表示该符号的对齐属性
-   可执行文件中。st_value表示符号的虚拟地址

### 特殊符号

### 符号修饰和函数签名

# 静态链接

## 空间和地址分配

### 按序叠加

将输入的目标文件按照次序叠加起来

![[链接、装载与库3.png]]

按序叠加在目标文件较多的时候那么最后的程序可能会有很多个零散的段，这样非常的浪费空间，因为每个段都有一定的地址和空间对齐要求，这样的话即便一个段的长度只有1个字节也要占用一页的内存空间也就是4096字节（x86）

### 相似段合并

将相同性质的段合并在一起

![[链接、装载与库4.png]]

**两步链接**

-   空间与地址分配 扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。 在这里，链接器将能够获得所有的输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系
-   符号解析与重定位 使用上一步中的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址

链接前后的程序中所使用的地址已经是程序在进程中的虚拟地址，即我们关心的是各个段中的VMA和Size，而忽略文件偏移，链接前目标文件所有的VMA都是0，因为虚拟地址还没有分配，所以偶默认为0，等到链接后，各个段都分配到对应的虚拟地址

## 符号解析与重定位

### 重定位

编译器会将不知道地址的指令地址用假地址来替代，将真正的地址计算工作交给链接器。链接器根据符号的地址对每个需要重定位的指令进行地址修正

### 重定位表

在ELF文件中，有一个叫做重定位表的结构专门用来保存这些与重定位相关的信息，对于可重定位的ELF文件，必须包含重定位表，用来描述如何修改相应的段里的内容。对于每个要被重定位的ELF段都有一个对应的重定位表，而一个重定位表往往就是ELF的一个段

每个要被重定位的地方叫一个重定位入口，重定位入口的偏移表示该入口要被重定位的段中的位置，“RELOCATION RECORDS FOR[.text]”表示这个重定位表是代码段的重定位表，所以偏移表示代码段中需要被调整的位置

### 符号解析

### 指令修正方式

-   近址寻址 远址寻址
-   绝对寻址 相对寻址
-   寻址长度 8位、16位、32位、64位

对于32位x86平台下的ELF文件只有两种

-   绝对近址32位寻址
-   相对近址32位寻址

绝对寻址修正修正后的地址为该符号的的实际地址

相对寻址修正后的地址为符号距离被修正位置的地址差

## COMMON块

********************************************************************多个符号定义类型不一致的情况********************************************************************

-   两个或两个以上强符号类型不一致 （多个强符号定义本身非法，链接器会报符号多重定义错误）
-   有一个强符号，其他都是弱符号，出现类型不一致
-   两个或两个以上弱符号类型不一致

COMMON块机制，在两个文件同时定义了相同的变量且都按照弱符号处理时，输出文件中变量的大小按照输入文件中最大的那个处理吗

# Windows PE/COFF

## COFF

### COFF文件结构

几乎和ELF文件一样。COFF也是由文件头和后面若干几个端组成，再加上文件末尾的符号表、调试信息的内容，就构成了COFF文件的基本结构，我们再COFF文件中几乎都可以找到与ELF文件结构相对应的地方。COFF文件的文件头部包括了两部分，一个是描述文件总体结构和属性的映像头，另外一个是描述该文件中包含的段属性的段表。文件头后面紧跟着的就是文件的段，包括代码段、数据段等，最后可能还有符号表

![[链接、装载与库5.png]]

映像头后跟着的就是COFF文件的段表，它是一个类型为“IMAGE_SECTION_HEADER”结构的数组，数组里面每个元素代表一个段，这个结构与ELF文件中的”Elf32_Shdr”很相似。这个结构是用来描述每个段的属性的

每个段拥有的属性包括段名、物理地址、虚拟地址、原始数据大小、段在文件中的位置、该段的重定位表在文件中的位置、该段的行号在文件中的位置

段表之后就每个段的实际内容了，下面介绍两个ELF文件中不存在的段表

-   .drectve
-   .debug$S

## 链接指示信息

“.drectve”实质上是“Directive”的缩写，它的内容是编译器传递给链接器的指令（Directive），即编译器希望告诉链接器应该怎么链接这个目标文件。段名后面就是段的属性，包括地址、长度、位置等我们这些在分析ELF文件时已经很熟知的属性，最后一个属性是标志位“flag”，即IMAGE_SECTION_HEADERS里面的Characteristics成员

## 调试信息

COFF文件中所有以“.debug”开始的段都包含着调试信息。比如“.debug$S”表示包含的是符号相关的调试信息段；“.debug$P”表示包含预编译头文件相关的调试信息段；“.debug$T”表示 包含类型相关的调试信息段

## Windows下的ELF——PE

PE文件是基于COFF的扩展，它比COFF文件多了几个结构。最主要的变化有两个：第一个是，文件的最开始部分不是COFF文件头，而是DOS MZ 可执行文件格式的文件头和桩代码；第二个是，原来的COFF文件头中的“IMAGE_FILE_HEADER”部分扩展成了PE文件文件头结构“IMAGE_NT_HEADERS”，这个结构包括了原来的”Image Header“及新增的PE扩展头部文件结构

![[链接、装载与库6.png]]

“IMAGE_NT_HEADERS”是PE真正的文件头，它包含了一个标记和两个结构体。标记是一个常量，对于一个合法的PE文件来说，它的值为0x00004550，按照小端字节序，对应的是”P“,”E”,”\0”,”\0”四个字符的ASCII码。文件头包含的两个结构分别是映像头、PE扩展文件头结构

### PE数据目录

在Windows装载PE可执行文件的时候，往往要很快的找到一些装载所需要的数据结构，比如导入表、导出表、资源、重定位表等。这些常用的 数据的位置和长度被保存在了一个叫做数据目录的结构里面，其实他就是前面”IMAGE_OPTIONAL_HEADER“结构里面”DataDirectory“成员，这个成员是一个”IMAGE_DATA_DIRECTORY”的结构数组，IMAGE_DATA_DIRECTORY结构有两个成员，分别是虚拟地址以及长度。DataDirectory数组里面每个元素都对应一个包含一定含义的表

# 可执行文件的装载与进程

## 进程虚拟地址

每个程序被运行起来以后，它将拥有自己的独立的虚拟空间，这个虚拟地址空间的大小由计算机的硬件平台决定，具体的说是由CPU的位数决定的硬件决定了地址空间的最大理论上限，即硬件的寻址空间大小，比如32位的硬件平台决定了虚拟空间的为 0 到 $2^{32}-1$,即0x00000000~0xFFFFFFFF,也就是我们常说的4GB虚拟空间大小；而64位的硬件平台具有64位寻址能力，它的虚拟空间大小达到了 $2^{64}$字节总共17 179 869 184GB

## 装载的方式

### 覆盖装入

覆盖装入将挖掘内存潜力的任务交给了程序员，程序员在编写程序的时候必须手工将程序分割为若干块，然后编写一个小的辅助代码来管理这些模块何时应该驻留内存而何时应该被替换掉。

在多个模块的时候，程序员需要手工将模块按照它们之间的调用依赖关系组织成树状结构

树状管理器需要保证两点：

-   这个树状结构从任意一个模块到树的根模块都叫做调用路径。当该模块被调用时，整个调用路径上的模块必须都在内存中，模块在执行时它的父模块必须在内存中，以确保模块执行完以后能够正确的返回父模块
-   禁止跨树间调用。任意一个模块不允许跨过树结构进行调用。因为覆盖管理器不能保证跨树间的模块能够存在于内存中

当然，由于跨模块间的调用都需要经过覆盖管理器，以确保所有被调用到的模块能够正确的驻留到内存中，而且一旦模块没有在内存中，还需要从磁盘或其他存储器读取相应的模块，所以覆盖装入的速度肯定比较慢，不过这也是一种折中的方案，是典型的时间换空间的方法

### 页映射

页映射是虚拟储存机制的一部分，它随着虚拟储存的发明而诞生。与覆盖装入的原理相似，页映射也不是一下子就把程序的所有数据和指令都装入内存，而是将内存和所有磁盘中的数据和指令按照”页”为单位划分为若干个页，以后所有的装载和操作单位就是页。以目前的情况，硬件规定的页的大小有4096字节、8192字节、2MB、4MB等，最常见的Intel IA32处理器一般都使用4096字节的页，那么512MB的物理内存就拥有512_1024_1024/4096=131072个页

假设我们的32位机器有16KB的内存。每个页的大小为4096字节，则·共有4个页F0~F3

假设程序所有指令和数据的总和为32KB，那么程序总共分为8个页。将它们分为P0~P7。很明显，16KB的内存无法同时将32KB的程序装入，那么我们将按照动态装入的原理来进行整个装入过程。如果程序刚开始执行时的入口地址在P0，这时装载管理器发现程序的P0不在内存中，于是装载管理器将内存F0分配给P0，并且，将P0的内容装入F0；运行一段时间以后，程序需要用到P5，于是装载管理器将P5装入F1，当程序需要用到P3和P6的时候，又分别F2,F3，然而如果此时程序需要访问P4，那么装载器就要做出选择，必须放弃当前正在使用中的四个内存页中的一个来装载P4，这个时候的选择就涉及到算法，比如选择F0，因为是第一个被分配的内存页（FIFO，先进先出算法）；如果发现F2很少被访问到，选择F2（LUR，最少使用算法）

事实上这个装载管理器就是现代的操作系统，更准确的说就是操作系统的存储管理器

## 从操作系统看可执行文件的装载

### 进程的建立

创建一个进程，然后装载相应的可执行文件并且执行，在有虚拟存储的时候，上述过程最开始只需要做三件事情：

-   创建一个独立的虚拟地址空间
-   读取可执行文件头、
-   将CPU的指令寄存器设置为可执行文件的入口地址，启动运行

首先是创建虚拟地址空间，一个虚拟空间有一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间创建映射函数所需要的相应的数据结构

读取可执行文件头，并且需要建立虚拟空间与可执行文件的映射关系。上一步的页映射关系函数是虚拟空间到物理内存的映射关系，这一步所作的是虚拟空间与可执行文件的映射关系。当程序执行发生页错误的时候，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。但是很明显的一点是，当操作系统捕获到缺页错误时，它应当知道程序当前所需要的页在可执行文件的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系

> 由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件

将CPU指令寄存器设置为可执行文件入口，启动执行

### 页错误

在上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有被装入内存中，操作系统只是通过可执行文件的头部信息建立起可执行文件和进程虚存之间的映射关系而已。当CPU开始执行这个地址的指令时发现，地址所在页面是一个空页面，于是认为是一个页错误。然后将控制权交给操作系统，操作系统专门的错误处理例程来处理。操作系统将查询这个数据结构，然后找到空白页面所在的VMA，计算出相应页面在可执行文件中的偏移，然后在把控制权还给进程，进程从刚刚页错误的位置重新开始执行

随着进程的执行，页错误也会不断的产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。当然有可能进程所需要的内存会超过可用的内存数量，特别是在有多个进程同时执行的时候，这个时候操作系统需要精心的组织和分配物理内存甚至有时候应将分配给进程的物理内存暂时收回

## 进程虚存空间分布

### ELF文件链接视图和执行视图

前面例子的可执行文件只有一个代码段，所以它被操作系统装载至进程地址空间之后，相应的只有一个VMA。不过实际情况会更加复杂，在一个正常的进程虚拟空间的往往只一个段

当段的数量增多时，就会产生空间浪费的问题。ELF文件在映射时是以系统的页长度作为单位的，那么 每个段·在映射时的长度应该是系统页长度的整数倍；如果不是，那么多余的部分也将占用一个页。一个ELF文件中往往有十几个段，那么内存空间的浪费是可想而知的

在ELF文件中，段的权限往往只有为数不多的几种组合，基本是以下三种：

-   以代码段为代表的权限可读可执行的段
-   以数据段和BSS段为代表的权限可读可写的段
-   以只读数据段为代表的权限为只读的段

那么有一个简单的方案：对于相同权限的段，把他们合并到一起当做一个段进行映射

ELF可执行文件引入了一个概念叫做“Segment”，一个“Segment”包含一个或多个属性类似的”Sect

ion”

“Segment”的概念实际上是从装载的角度重新划分了ELF的各个段。在将目标文件链接成可执行文件的时候，链接器会尽量把相同的权限属性的段分配在同一空间

### 堆和栈

在操作系统中，VMA除了用来映射可执行文件中各个”Segment“以外，它还可以有其他作用，操作系统通过使用VMA来对进程的地址空间进行管理。我们知道进程在执行的时候它还需要用到栈（Stack）、堆{Heap）等空间，事实上它们在进程的虚拟空间中的表现也是以VMA的形式存在的，很多情况下，一个进程的栈和堆分别都有一个对应的的VMA

一个进程基本可以划分为以下几种VMA区域：

-   代码VMA，权限只读、可执行；有映像文件。you
-   数据VMA，权限可读写、可执行；有映像文件
-   堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展
-   栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展

### 堆的最大申请数量

### 段地址对齐

有些Unix系统让各个段接壤部分共享一个物理页面，然后将该物理页面分别映射两次

### 进程栈初始化

在进程初始化后的堆栈，栈顶寄存器esp指向的位置是初始化以后的堆栈顶部，最前面的4个字节表示命令行参数的数量

## Linux内核装载ELF过程简介

当在Linux系统的bash下输入一个命令执行某个ELF程序时，Linux系统是怎么样装载这个ELF文件并且执行它的呢

首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后等待用户输入命令

进入execve()系统调用之后，Linux内核就开始进行真正的装载工作。在内核中execve()系统调用的相应的入口是sys_execve()，它被定义在arch\i386\kernel\Process.c。sys_execve()进行一些参数的检查复制之后，调用do_execve()。do_execve()会首先查找被执行的文件，如果找到文件，则读取文件的128个字节。

当do_execve()读取了128字节的的文件头部之后，然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理过程。ELF可执行文件的装载，load_elf_binary()被定义在fs/Binfmt_elf.c，主要步骤：

-   检查ELF可执行文件格式的有效性，比如魔数、程序头表中段的数量
-   寻找动态链接的”.interp“段，设置动态链接器路径（与动态链接有关）
-   跟据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据
-   初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是DT_FINI的地址
-   将系统调用的返回地址修改成ELF文件可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中e_entry所指地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器

当load_elf_binary()执行完毕，返回至do_execve()再返回至sys_execve()时，上面的第5步中已经把系统调用的返回地址被改成被装载的ELF程序的入口地址了。所以当sys_execve()系统调用从内核态返回用户态时，EIP寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成

## Windows PE的装载

PE文件的装载跟ELF文件有所不同，由于PE文件中，所有的段的起始地址都是页的，段的长度如果不是页的整倍数，那么在映射时向上补齐到页的整倍数，我们也可以简单的认为在32位的PE文件中，段的起始地址和长度都是4096字节的整数倍，我们也可以简单地认为在32位的PE文件中，段的起始地址和长度都是4096字节的整数倍。由于这个特点PE文件的映射过程会比ELF简单得多，因为它无需考虑如ELF里面诸多段地址对齐之类的问题，虽然这样会浪费一些磁盘和内存空间。PE可执行文件的段的数量很少，不像ELF文件中经常有十多个”Section“，最后不得不使用”Segment”的概吧它们合并到一起装载，PE文件中，链接器在生产可执行文件时，往往将所有的段都尽可能的合并，所以一般只有代码段、数据段、只读文件段和BSS段等为数不多的几个段

在讨论结构的具体装载过程之前，我们要引入一个PE里面很常见的术语叫做RVA，它表示一个相对虚拟地址。这个术语看起来比较晦涩难懂，其实它的概念很简单，就是相当于文件中的偏移量的东西。它是相对于PE文件的转载基地址的一个偏移地址。每个PE文件被设计成可以装载到任何地址，所以这个基地址并不是固定的，每次装载时都可能会变化。如果PE文件中的地址都使用绝对地址，它们都要随着基地址的变化而变化。但是，如果使用RVA这样一种基于基地址的相对地址，那么无论基地址怎么变化，PE文件中各个RVA都保持一致。这里涉及PE可执行文件装载的一些内容，我们只是简单介绍

装载一个PE可执行文件的过程：

-   先读取文件的第一个页，在这个页中，包含了DOS头，PE文件头和段表、
-   检查进程地址空间中，目标地址是否可用，如果不可用，则另外选一个装载地址。这个问题对于可执行文件来说基本不存在，因为它往往时进程第一个装入的模块，所以这个问题对于可执行文件来说不太可能被占用。因为它往往是进程第一个装入的模块，所以目标地址不太可能被占用
-   根据段表中提供的信息，将PE文件中所有的段一一映射到地址空间文件中相应的位置
-   如果装载地址不是目标地址，则进行Rebasing
-   装载所有PE文件所需要的DLL文件
-   对PE文件中所有的导入符号进行解析
-   根据PE头中指定的参数，建立初始化栈和堆
-   建立主线程并且启动进程

# 动态链接

## 为什么要动态链接

### 内存和磁盘空间

静态链接的方式对于计算机的内存和磁盘的空间浪费非常严重。特别是多进程操作系统的情况下，静态链接的方式对于计算机内存和磁盘的空间浪费非常严重。特别是多进程操作系统的情况下，静态链接极大的浪费了内存空间

### 动态链接

要解决空间浪费和更新困难这两个问题的最简单的方法就是把程序的模块互相分割开，形成独立的文件，而不再将它们静态的链接在一起。简单的讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行的时候才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是动态链接的基本思想

以progrem1和progrem2为例，假设我们保留progrem1.o、progrem2.o和Lib.o三个目标文件·。当我们要运行progrem1这个程序时，系统首先加载progrem1.o，当系统首先发现progrem1.o中用到了Lib.o，即progrem1.o依赖于Lib.o，那么系统接着加载Lib.o，如果progrem.o或Lib.o还依赖于其他目标文件，系统就会按照这种方法将它们全部加载至内存。所以需要的目标文件加载结束后，如果依赖关系满足，即所有的依赖的目标文件都存在于磁盘，系统开始链接工作。这个给链接工作的原理与静态链接非常相似，包括符号解析、地址重定位等。完成这些步骤后，系统开始把控制权交给progrem1.o的程序入口处，程序开始运行，这个时候如果我们需要运行progrem2，那么系统就只需要加载progrem2.o，而不需要重新加载Lib.o，因为中已经存在了一份Lib.o的副本，系统要做的就只是将progrem2.o和Lib.o链接再一起

这样的作法解决了共享的目标文件多个副本浪费磁盘和把内存空间的问题，可以看到，磁盘和内存中只存在一份Lib.o，而不是两份。另外再内存中共享一个目标文件模块换来的好处不仅仅是节省内存，它还可以减少物理页面的换入和换出，也可以增加CPU缓存的命中率，因为不同进程间的数据和指令访问都集中在同一个共享模块上

当我们要升级一个程序的某个模块时，理论上只要简单的将旧的目标文件覆盖掉，而无需将所有的程序再重新链接一遍，当程序下一次运行的时候，新版本的目标文件会被自动装载到内存并且链接起来，程序就完成了升级的目标

### 程序的可扩展性和兼容性

动态链接还有一个特点就是程序在运行的时候可以动态的选择加载各种程序模块，这个优点就是后来被人们用来制作程序的插件

比如某个公司开发完成了某个产品，它按照一定的规则指定好程序的接口，其他公司或开发者可以按照这种接口来编写符合要求的动态链接文件。该产品程序可以动态的载入各种由第三方开发的模块，在程序运行时动态的链接，实现程序功能的扩展

动态链接还可以加强出现的兼容性。一个程序在不同的平台运行时可以动态地链接到由操作系统提供的动态链接库，这些动态链接库相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对于不同的平台之间的依赖的差异性。比如操作系统A和操作系统B对于print()的实现机制不同，如果我们的程序时静态链接的，那么程序需要分别链接成能够在A运行和在B运行的两个版本并且分开发布；但是如果是动态链接，只要操作系统A和操作系统B都能提供一个动态链接库包含print()，并且这个print()使用相同的接口，那么程序只需要由一个版本，就可以在两个操作系统运行，动态的选择相应的print()实现版本

从上面的描述来看，动态链接是不是一种“万能膏药”呢？很遗憾，动态链接也有诸多的问题和令人烦恼和费解的地方。很常见的一个问题是，当程序所依赖的某个模块更新后，由于新的模块和旧的模块接口不兼容，导致了原有的程序无法运行。这个问题在早期的Windows版本中尤为严重，因为它们缺少一种有效的共享库版本管理机制，使得用户经常出现新程序安装完之后，其他某个程序无法正常工作的现象，这个问题页经常被称为“DLL Hell”

### 动态链接的基本实现

动态链接的基本思想是把程序按照模块拆分为各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完整程序，而不是像静态链接一样把所哟有的程序模块都链接成一个单独的可执行文件。那么我们能不能按照前面例子中所描述的那样，直接使用目标文件进行动态链接？理论上是可行的，但是实际上动态链接的实现方案与直接使用目标文件稍有区别。

动态链接涉及运行时的链接及多个文件的装载，必须要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间分布会比静态链接情况下更为复杂，还有一些储存管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。目前的主流操作系统几乎都支持动态链接这种方式，在Linux系统中，ELF动态链接文件被称为动态共享对象(DSO)，简称共享对象，它们一般都是以“.so”为扩展名的一些文件；而在Windows系统中，动态链接文件被称为动态链接库，它们就是平时很常见的以“.dll”为扩展名的文件

在Linux中，常用C语言的运行库glibc，它的动态链接形式的版本保存在“/lib”目录下，文件名叫做“[libc.so](http://libc.so)”。整个系统只保留一份C语言库的动态链接文件“[libc.so](http://libc.so)”而所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载的时候系统的动态链接器会将程序所需要的所有未决议的符号绑定到相应的动态链接库中，并且进行重定位工作

程序与libc.so之间真正的链接工作是由动态链接器完成的，而不是由我们前面看到过的静态链接器Id完成的。也就是说，动态链接是把链接这个过程从本来的程序装载前被推迟到了装载的时候，动态按揭会导致程序在性能方面的一些损失，但是对动态链接的链接过程可以进行优化，比如后面的延迟绑定等方法，可以使得动态链接的性能尽可能的减小

## 地址无关代码

### 固定装载地址的困扰

在早器的系统采用了手工指定程序各个模块地址的方法，称之为静态共享库

### 装载是重定位

为了让共享对象在任意地址装载，我们首先想到的方法就是静态链接中的重定位。基本思路是，在连接时，对所有的绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对所有的绝对地址引用进行重定位。

在前面静态链接时提过重定位，那时的重定位叫做链接重定位，而现在这种情况叫做装载时重定位，在Windows中，这种装载时的重定位又被叫做基址重置

Linux和GCC支持这种装载时重定位的方法，我们在前面产生共享对象时，使用了两个GCC参数“-shared”和“-fPIC”，如果只使用“-shared”，那么输出的共享对象就是使用装载时重定位的方法

### 地址无关代码